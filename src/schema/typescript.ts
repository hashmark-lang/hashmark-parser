import * as ts from "typescript";
import { capitalize } from "../utils";
import { ArgSchema, BlockSchema, BodyPropSchema, InlineSchema, Schema } from "./Schema";

const STRING_TYPE = ts.createKeywordTypeNode(ts.SyntaxKind.StringKeyword);
const NULL_TYPE = ts.createKeywordTypeNode(ts.SyntaxKind.NullKeyword);
const EXPORT_MODIFIER = [ts.createModifier(ts.SyntaxKind.ExportKeyword)];

interface TypescriptConverterOptions {
	target: ts.ScriptTarget;
	newLine: ts.NewLineKind;
}

const defaultOptions: TypescriptConverterOptions = {
	target: ts.ScriptTarget.Latest,
	newLine: ts.NewLineKind.LineFeed
};

export function convertSchemaToTypescript(
	schema: Schema,
	conversionOptions: Partial<TypescriptConverterOptions> = defaultOptions
): string {
	const options = { ...defaultOptions, ...conversionOptions };
	const blockIdentifiers = createIdentifierMap(
		schema.blocks.concat(schema.rootSchema).map(_ => _.tag),
		"block"
	);
	const inlineIdentifiers = createIdentifierMap(schema.inlines.map(_ => _.tag), "inline");

	function createBlockInterface(block: BlockSchema): ts.InterfaceDeclaration {
		const typeName = blockIdentifiers.get(block.tag)!;
		const propsTypes = block.bodyProps.map(prop => createBodyProp(prop));
		if (block.head) {
			propsTypes.push(createArgProp(block.head));
		}
		return createTag(typeName, block.tag, propsTypes);
	}

	function createBodyProp(prop: BodyPropSchema): ts.TypeElement {
		if (prop.raw) {
			return createInterfaceMember(prop.name, ts.createArrayTypeNode(STRING_TYPE));
		}
		const refs = prop.children.map(child =>
			ts.createTypeReferenceNode(blockIdentifiers.get(child)!, undefined)
		);
		if (prop.isArrayType) {
			return createInterfaceMember(
				prop.name,
				ts.createArrayTypeNode(ts.createUnionTypeNode(refs))
			);
		} else if (prop.cardinality.max === 0) {
			return createInterfaceMember(prop.name, NULL_TYPE);
		} else if (prop.cardinality.min === 0) {
			return createInterfaceMember(prop.name, ts.createUnionTypeNode([...refs, NULL_TYPE]));
		} else if (prop.cardinality.min === 1 && prop.cardinality.max === 1) {
			return createInterfaceMember(prop.name, ts.createUnionTypeNode(refs));
		} else {
			throw new Error("Unrecognised cardinality");
		}
	}

	function createInline(inline: InlineSchema): ts.InterfaceDeclaration {
		const typeName = inlineIdentifiers.get(inline.tag)!;
		const propsTypes = inline.args.map(arg => createArgProp(arg));
		return createTag(typeName, inline.tag, propsTypes);
	}

	function createArgProp(arg: ArgSchema): ts.TypeElement {
		switch (arg.type) {
			case "parsed":
				const refs: ts.TypeNode[] = Array.from(arg.validChildren).map(tag =>
					ts.createTypeReferenceNode(inlineIdentifiers.get(tag)!, undefined)
				);
				return createInterfaceMember(
					arg.name,
					ts.createArrayTypeNode(ts.createUnionTypeNode(refs.concat(STRING_TYPE)))
				);
			case "date":
				return createInterfaceMember(
					arg.name,
					ts.createTypeReferenceNode("Date", undefined)
				);
			case "string":
				return createInterfaceMember(arg.name, STRING_TYPE);
			case "url":
				return createInterfaceMember(
					arg.name,
					ts.createTypeReferenceNode("URL", undefined)
				);
		}
	}

	const blocks = [schema.rootSchema, ...schema.blocks].map(block => createBlockInterface(block));
	const inlines = schema.inlines.map(inline => createInline(inline));
	const blockTypes = blocks.map(i => ts.createTypeReferenceNode(i.name, undefined));
	const inlineTypes = inlines.map(i => ts.createTypeReferenceNode(i.name, undefined));
	const blockUnion = createUnionTypeAlias("BlockTag", blockTypes);
	const inlineUnion = createUnionTypeAlias("InlineTag", inlineTypes);
	const union = createUnionTypeAlias("Tag", [
		ts.createTypeReferenceNode(blockUnion.name, undefined),
		ts.createTypeReferenceNode(inlineUnion.name, undefined)
	]);
	ts.addSyntheticLeadingComment(
		union,
		ts.SyntaxKind.MultiLineCommentTrivia,
		" This file was generated by Hashml https://github.com/hashml/hashml ",
		true
	);
	const nodes = [union, blockUnion, inlineUnion, ...blocks, ...inlines];
	return printTypescript(nodes, options);
}

function printTypescript(nodes: ts.Node[], options: TypescriptConverterOptions): string {
	const declarationFile = ts.createSourceFile(
		"out.d.ts",
		"",
		options.target,
		false,
		ts.ScriptKind.TS
	);

	const printer = ts.createPrinter({ newLine: options.newLine });
	return printer.printList(ts.ListFormat.MultiLine, ts.createNodeArray(nodes), declarationFile);
}

function createIdentifierMap(names: string[], prefix: string): ReadonlyMap<string, ts.Identifier> {
	const identifierCounts: Map<string, number> = new Map();
	function identifier(name: string): ts.Identifier {
		let id = capitalize(prefix) + capitalize(name).replace(/\W+/g, "_");
		const count = identifierCounts.get(id);
		identifierCounts.set(id, (count || 0) + 1);
		if (count) {
			id += "_" + count;
		}
		return ts.createIdentifier(id);
	}
	return new Map(names.map(name => [name, identifier(name)]));
}

function createTag(
	typeName: ts.Identifier,
	tagName: string,
	props: ts.TypeElement[]
): ts.InterfaceDeclaration {
	return createInterface(typeName, [
		createInterfaceMember("tag", ts.createLiteralTypeNode(ts.createStringLiteral(tagName))),
		createInterfaceMember("props", ts.createTypeLiteralNode(props))
	]);
}

function createInterface(
	name: string | ts.Identifier,
	members: ts.TypeElement[]
): ts.InterfaceDeclaration {
	return ts.createInterfaceDeclaration(
		undefined, // decorators
		EXPORT_MODIFIER,
		name,
		undefined, // type parameters
		undefined, // heritage clauses
		members
	);
}

function createInterfaceMember(name: string, type: ts.TypeNode): ts.TypeElement {
	return ts.createPropertySignature(
		undefined, // modifiers
		name,
		undefined, // question token
		type,
		undefined // initializer
	);
}

function createUnionTypeAlias(name: string, types: ts.TypeNode[]) {
	return ts.createTypeAliasDeclaration(
		undefined, // decorators
		EXPORT_MODIFIER, // modifiers
		name,
		undefined, // type parameters
		ts.createUnionTypeNode(types)
	);
}
